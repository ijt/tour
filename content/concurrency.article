Concurrency
Go provides concurrency constructions as part of the core language. This lessons presents them and gives some examples on how to use it.

The Go Authors
https://golang.org

* Goroutines

A _goroutine_ is a lightweight thread managed by the Go runtime.

	go f(x, y, z)

starts a new goroutine running

	f(x, y, z)

The evaluation of `f`, `x`, `y`, and `z` happens in the current goroutine and the execution of `f` happens in the new goroutine.

Goroutines run in the same address space, so access to shared memory must be synchronized. The [[https://golang.org/pkg/sync/][`sync`]] package provides useful primitives, although you won't need them much in Go as there are other primitives. (See the next slide.)

.play concurrency/goroutines.go

* Channels

Channels are a typed conduit through which you can send and receive values with the channel operator, `<-`.

	ch <- v    // Send v to channel ch.
	v := <-ch  // Receive from ch, and
	           // assign value to v.

(The data flows in the direction of the arrow.)

Like maps and slices, channels must be created before use:

	ch := make(chan int)

By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.

The example code sums the numbers in a slice, distributing the work between two goroutines.
Once both goroutines have completed their computation, it calculates the final result.

.play concurrency/channels.go

* Close

A sender can `close` a channel to indicate that no more values will be sent. Once a channel is closed, subsequent receives from the channel will proceed immediately and yield the zero value of the channel's type.

Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after

	v, ok := <-ch

`ok` is `false` if there are no more values to receive and the channel is closed.

*Note:* Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.

*Another*note*: Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a loop.

.play concurrency/close.go

* Map/reduce

A common pattern is to start up a number of worker goroutines to process a subset of a larger pile of work.  We can use a channel to communicate back the result from each goroutine.

.play concurrency/workers.go

* Goroutines and closures

Goroutine functions are typically closures.  A common pitfall is to write the first loop as:

	for i := 0; i < numWorkers; i++ {
		go func() {
                        // Data race!
                        start, end := workerRange(i)
			n, err := countTrue(bigData[start:end])
			ch <- result{id: i+1, n: n, err: err}
		}()
	}

This is incorrect, because the `i` variable is written to in the main goroutine, while being read concurrently in the worker goroutines without any synchronization.

A common solution is to create a new variable for each iteration of the loop.

*Note:* Data races like this can be detected at runtime by compiling your Go program with the `-race` flag.

.play concurrency/workers-closure.go

* Select

Let's examine another common scenario: if one of the computations fails, we want to stop the other long-running computations. We need to wait on two channels: the operation and the cancelation signal. To help us, we use the `select` statement.

The `select` statement lets a goroutine wait on multiple communication operations.

A `select` blocks until one of its cases can run, then it executes that case.  It chooses one at random if multiple are ready.

.play concurrency/workers-cancel.go

* Context

Cancelation is prevalent enough in Go that there is a standard type used to pass around the cancelation signal (as well as other cross-cutting values): `Context`.

`Context` has two relevant methods: `Done()`, which returns a channel that is closed when its cancel function is called, and `Err()`, which returns the reason for the channel's closing.

By convention, `Context` is the first parameter of any function that needs one.

.play concurrency/workers-context.go

* Exercise: Equivalent Binary Trees

There can be many different binary trees with the same sequence of values stored at the leaves. For example, here are two binary trees storing the sequence 1, 1, 2, 3, 5, 8, 13.

.image /content/img/tree.png

A function to check whether two binary trees store the same sequence is quite complex in most languages. We'll use Go's concurrency and channels to write a simple solution.

This example uses the `tree` package, which defines the type:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}


Continue description on [[javascript:click('.next-page')][next page]].

* Exercise: Equivalent Binary Trees

*1.* Implement the `Walk` function.

*2.* Test the `Walk` function.

The function `tree.New(k)` constructs a randomly-structured binary tree holding the values `k`, `2k`, `3k`, ..., `10k`.

Create a new channel `ch` and kick off the walker:

	go Walk(tree.New(1), ch)

Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, ..., 10.

*3.* Implement the `Same` function using `Walk` to determine whether `t1` and `t2` store the same values.

*4.* Test the `Same` function.

`Same(tree.New(1),`tree.New(1))` should return true, and `Same(tree.New(1),`tree.New(2))` should return false.

The documentation for `Tree` can be found [[https://godoc.org/golang.org/x/tour/tree#Tree][here]].

.play concurrency/exercise-equivalent-binary-trees.go

* sync.Mutex

We've seen how channels are great for communication among goroutines.

But what if we don't need communication? What if we just want to make sure only
one goroutine can access a variable at a time to avoid conflicts?

This concept is called _mutual_exclusion_, and the conventional name for the data structure that provides it is _mutex_.

Go's standard library provides mutual exclusion with
[[https://golang.org/pkg/sync/#Mutex][`sync.Mutex`]] and its two methods:

- `Lock`
- `Unlock`

We can define a block of code to be executed in mutual exclusion by surrounding it
with a call to `Lock` and `Unlock` as shown on the `Inc` method.

We can also use `defer` to ensure the mutex will be unlocked as in the `Value` method.

.play concurrency/mutex-counter.go

* Exercise: Web Crawler

In this exercise you'll use Go's concurrency features to parallelize a web crawler.

Modify the `Crawl` function to fetch URLs in parallel without fetching the same URL twice.

_Hint_: you can keep a cache of the URLs that have been fetched on a map, but maps alone are not
safe for concurrent use!

.play concurrency/exercise-web-crawler.go

* Where to Go from here...

#appengine: You can get started by
#appengine: [[https://golang.org/dl/][installing Go]].

#appengine: Once you have Go installed, the
The
[[https://golang.org/doc/][Go Documentation]] is a great place to
#appengine: continue.
start.
It contains references, tutorials, videos, and more.

To learn how to organize and work with Go code, watch [[https://www.youtube.com/watch?v=XCsL89YtqCs][this screencast]] or read [[https://golang.org/doc/code.html][How to Write Go Code]].

If you need help with the standard library, see the [[https://golang.org/pkg/][package reference]]. For help with the language itself, you might be surprised to find the [[https://golang.org/ref/spec][Language Spec]] is quite readable.

To further explore Go's concurrency model, watch
[[https://www.youtube.com/watch?v=f6kdp27TYZs][Go Concurrency Patterns]]
([[https://talks.golang.org/2012/concurrency.slide][slides]])
and
[[https://www.youtube.com/watch?v=QDDwwePbDtw][Advanced Go Concurrency Patterns]]
([[https://talks.golang.org/2013/advconc.slide][slides]])
and read the
[[https://golang.org/doc/codewalk/sharemem/][Share Memory by Communicating]]
codewalk.

To get started writing web applications, watch
[[https://vimeo.com/53221558][A simple programming environment]]
([[https://talks.golang.org/2012/simple.slide][slides]])
and read the
[[https://golang.org/doc/articles/wiki/][Writing Web Applications]] tutorial.

The [[https://golang.org/doc/codewalk/functions/][First Class Functions in Go]] codewalk gives an interesting perspective on Go's function types.

The [[https://blog.golang.org/][Go Blog]] has a large archive of informative Go articles.

Visit [[https://golang.org][golang.org]] for more.

